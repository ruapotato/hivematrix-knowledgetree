<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>KnowledgeTree</title>
    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
    <div class="card">
        <div class="card__header">
            <h1 class="card__title">KnowledgeTree - Documentation & Knowledge Base</h1>
        </div>
        <div class="card__body">
            <p class="u-mb-3">Browse and search organizational knowledge, documentation, and technical resources.</p>
            {% if user.permission_level == 'admin' %}
            <a href="{{ url_for('admin_settings') }}">
                <button class="btn btn--secondary">
                    <span class="btn__label">
                        <i data-lucide="settings" class="btn__icon"></i>
                        Admin Settings
                    </span>
                </button>
            </a>
            {% endif %}
        </div>
    </div>

    <div class="card" id="file-browser-container">
        <div class="card__header">
            <div class="header-toolbar">
                {% if current_path %}
                    <a href="{{ url_for('browse', path=parent_path) }}">
                        <button class="btn">
                            <span class="btn__label">‚Üê Back</span>
                        </button>
                    </a>
                {% endif %}

                <div class="breadcrumb">
                    <strong>Path:</strong>
                    <span class="breadcrumb__separator"></span>
                    <a href="{{ url_for('browse', path='') }}" class="breadcrumb__link">root</a>
                    {% for name in breadcrumb_names[1:] %}
                        {% set path_slice = breadcrumb_names[1:loop.index+1] %}
                        <span class="breadcrumb__separator">/</span>
                        <a href="{{ url_for('browse', path=(path_slice | map('quote_plus') | join('/'))) }}" class="breadcrumb__link">{{ name }}</a>
                    {% endfor %}
                </div>
            </div>
        </div>
        <div class="card__body u-p-2">
            <div class="u-flex" style="justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <div class="input-group" style="width: 470px;">
                    <select id="search-scope" class="form-group__input" style="width: 170px;">
                        <option value="current">Current Folder</option>
                        <option value="all">All Items</option>
                    </select>
                    <input type="search" id="search-input" placeholder="Search..." class="form-group__input"
                           autocomplete="off" data-start-node="{{ current_node_id }}" style="width: 300px;">
                </div>
                <div class="view-switcher">
                    <button class="view-switcher__button view-switcher__button--active" id="view-grid" title="Icons">
                        <i data-lucide="grid" style="width: 20px; height: 20px;"></i>
                    </button>
                    <button class="view-switcher__button" id="view-tree" title="Compact">
                        <i data-lucide="list" style="width: 20px; height: 20px;"></i>
                    </button>
                    <button class="view-switcher__button" id="view-hierarchy" title="Tree">
                        <i data-lucide="folder-tree" style="width: 20px; height: 20px;"></i>
                    </button>
                </div>
            </div>
            <div id="file-browser" class="file-browser" style="opacity: 0;">
                {% for item in items %}
                    <div class="file-item {% if item.read_only %}file-item--read-only{% endif %}"
                         data-name="{{ item.name }}"
                         data-id="{{ item.id }}"
                         data-is-folder="{{ item.is_folder|lower }}">
                        {% if item.is_folder %}
                            {% if item.is_attached %}
                                <span class="file-item__icon">üìé</span>
                            {% else %}
                                <span class="file-item__icon">üìÅ</span>
                            {% endif %}
                        {% else %}
                            <span class="file-item__icon">üìÑ</span>
                        {% endif %}
                        <span class="file-item__name">{{ item.name }}</span>
                    </div>
                {% endfor %}
            </div>
        </div>
    </div>

    <div id="context-menu" class="context-menu">
        <ul class="context-menu__list">
            <li id="context-open" class="context-menu__item context-menu__item--item-action">Open</li>
            <li id="context-rename" class="context-menu__item context-menu__item--item-action">Rename</li>
            <li id="context-move" class="context-menu__item context-menu__item--item-action">Move</li>
            <li id="context-delete" class="context-menu__item context-menu__item--item-action">Delete</li>
            <hr id="context-separator" class="context-menu__separator">
            <li id="context-new-folder" class="context-menu__item context-menu__item--create-action">New Folder</li>
            <li id="context-new-attached" class="context-menu__item context-menu__item--create-action">New Attached Folder</li>
            <li id="context-new-article" class="context-menu__item context-menu__item--create-action">New Article</li>
        </ul>
    </div>

    <div id="move-modal" class="modal">
        <div class="modal__dialog">
            <div class="modal__header">
                <h2 class="modal__title">Move Item</h2>
                <span id="close-move-modal" class="modal__close">&times;</span>
            </div>
            <div class="modal__body">
                <p>Click on a folder to select it as the destination. Click the arrows to expand/collapse folders.</p>
                <div id="folder-list" class="u-mt-2"></div>
            </div>
            <div class="modal__footer">
                <button id="cancel-move-btn" class="btn">
                    <span class="btn__label">Cancel</span>
                </button>
                <button id="confirm-move-btn" class="btn btn--primary">
                    <span class="btn__label">Move Here</span>
                </button>
            </div>
        </div>
    </div>

    <div id="search-results" class="dropdown"></div>

    <script>
        const CURRENT_PATH = "{{ current_path }}";
        const CURRENT_NODE_ID = "{{ current_node_id }}";

        // File browser interactions
        const fileBrowser = document.getElementById('file-browser');
        const contextMenu = document.getElementById('context-menu');
        let selectedItemId = null;
        let createParentId = null; // Track parent folder for creating new items

        // Function to attach click handlers to file items
        function attachFileItemHandlers() {
            fileBrowser.querySelectorAll('.file-item').forEach(item => {
                item.addEventListener('click', () => {
                    const isFolder = item.dataset.isFolder === 'true';
                    const id = item.dataset.id;
                    const name = item.dataset.name;

                    if (isFolder) {
                        const newPath = CURRENT_PATH ? `${CURRENT_PATH}/${encodeURIComponent(name)}` : encodeURIComponent(name);
                        window.location.href = `{{ url_for('browse', path='') }}${newPath}`;
                    } else {
                        window.location.href = `{{ url_for('view_node', node_id='') }}${id}`;
                    }
                });
            });
        }

        // Initial attachment
        if (fileBrowser) {
            attachFileItemHandlers();
        }

        // Context menu
        document.getElementById('file-browser-container').addEventListener('contextmenu', (e) => {
            e.preventDefault();
            // Support both file-item (grid/tree view) and hierarchy-item (hierarchy view)
            const targetItem = e.target.closest('.file-item') || e.target.closest('.hierarchy-item');

            // Get menu items
            const itemActions = document.querySelectorAll('.context-menu__item--item-action');
            const createActions = document.querySelectorAll('.context-menu__item--create-action');
            const separator = document.getElementById('context-separator');

            if (targetItem) {
                // Right-clicked on an item
                document.querySelectorAll('.file-item, .hierarchy-item').forEach(el => {
                    el.classList.remove('file-item--selected', 'hierarchy-item--selected');
                });
                targetItem.classList.add(targetItem.classList.contains('hierarchy-item') ? 'hierarchy-item--selected' : 'file-item--selected');
                selectedItemId = targetItem.dataset.id;

                const isFolder = targetItem.dataset.isFolder === 'true';

                if (isFolder) {
                    // Right-clicked on a folder - show both item actions AND create actions
                    itemActions.forEach(el => el.classList.remove('context-menu__item--hidden'));
                    createActions.forEach(el => el.classList.remove('context-menu__item--hidden'));
                    separator.classList.remove('context-menu__item--hidden');
                    createParentId = selectedItemId; // Create items inside this folder
                } else {
                    // Right-clicked on a file - show only item actions
                    itemActions.forEach(el => el.classList.remove('context-menu__item--hidden'));
                    createActions.forEach(el => el.classList.add('context-menu__item--hidden'));
                    separator.classList.add('context-menu__item--hidden');
                    createParentId = CURRENT_NODE_ID;
                }
            } else {
                // Right-clicked on empty space - show create actions, hide item actions
                selectedItemId = null;
                createParentId = CURRENT_NODE_ID; // Create in current folder

                itemActions.forEach(el => el.classList.add('context-menu__item--hidden'));
                createActions.forEach(el => el.classList.remove('context-menu__item--hidden'));
                separator.classList.add('context-menu__item--hidden');
            }

            contextMenu.style.display = 'block';
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
        });

        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target)) {
                contextMenu.style.display = 'none';
                // Clear selection when closing context menu
                document.querySelectorAll('.file-item, .hierarchy-item').forEach(el => {
                    el.classList.remove('file-item--selected', 'hierarchy-item--selected');
                });
            }
        });

        // Context menu actions
        async function createNewItem(isFolder, isAttached = false) {
            const type = isAttached ? 'attached folder' : (isFolder ? 'folder' : 'article');
            const name = prompt(`Enter name for new ${type}:`);
            if (name) {
                const parentId = createParentId || CURRENT_NODE_ID;
                const response = await fetch('{{ url_for("create_node") }}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({
                        name,
                        parent_id: parentId,
                        is_folder: isFolder,
                        is_attached: isAttached
                    })
                });
                if (response.ok) {
                    const result = await response.json();
                    if (!isFolder) {
                        // Open new articles in edit mode
                        window.location.href = `{{ url_for('view_node', node_id='') }}${result.id}?edit=true`;
                    } else {
                        // If creating in current folder, add to view without reload
                        if (parentId === CURRENT_NODE_ID || currentView === 'hierarchy') {
                            // Reload or add to DOM depending on view
                            window.location.reload();
                        } else {
                            // Created in a subfolder, just clear cache
                            cachedFolderTree = null;
                        }
                    }
                }
            }
        }

        document.getElementById('context-new-folder').addEventListener('click', () => createNewItem(true, false));
        document.getElementById('context-new-attached').addEventListener('click', () => createNewItem(true, true));
        document.getElementById('context-new-article').addEventListener('click', () => createNewItem(false, false));

        document.getElementById('context-rename').addEventListener('click', async () => {
            if (!selectedItemId) return;
            const itemElement = document.querySelector(`.file-item[data-id="${selectedItemId}"], .hierarchy-item[data-id="${selectedItemId}"]`);
            const currentName = itemElement ? itemElement.dataset.name : '';
            const newName = prompt("Enter new name:", currentName);
            if (newName && newName !== currentName) {
                const response = await fetch(`{{ url_for('update_node', node_id='') }}${selectedItemId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({ name: newName })
                });

                if (response.ok) {
                    // Update the name in DOM without reloading
                    const nameElement = itemElement.querySelector('.file-item__name, .hierarchy-item__name');
                    if (nameElement) {
                        nameElement.textContent = newName;
                    }
                    itemElement.dataset.name = newName;

                    // Invalidate cache
                    cachedFolderTree = null;
                }
            }
        });

        document.getElementById('context-delete').addEventListener('click', async () => {
            if (!selectedItemId) return;
            if (confirm("Are you sure you want to delete this item and all its contents?")) {
                const response = await fetch(`{{ url_for('delete_node', node_id='') }}${selectedItemId}`, {
                    method: 'DELETE',
                    credentials: 'same-origin'
                });

                if (response.ok) {
                    // Remove from DOM without reloading
                    const itemElement = document.querySelector(`.file-item[data-id="${selectedItemId}"], .hierarchy-item[data-id="${selectedItemId}"]`);
                    if (itemElement) {
                        // In hierarchy view, also remove the children container
                        if (itemElement.classList.contains('hierarchy-item')) {
                            const childrenDiv = itemElement.nextElementSibling;
                            if (childrenDiv && childrenDiv.classList.contains('hierarchy-children')) {
                                childrenDiv.remove();
                            }
                        }
                        itemElement.remove();
                    }

                    // Remove from expanded folders set if it was a folder
                    expandedFolders.delete(selectedItemId);
                    saveExpandedState();

                    // Invalidate cache
                    cachedFolderTree = null;

                    // Clear selection
                    selectedItemId = null;
                }
            }
        });

        document.getElementById('context-open').addEventListener('click', () => {
            if (selectedItemId) {
                const itemElement = document.querySelector(`.file-item[data-id="${selectedItemId}"], .hierarchy-item[data-id="${selectedItemId}"]`);
                if(itemElement) itemElement.click();
            }
        });

        // Move functionality
        let selectedDestinationId = null;
        let cachedFolderTree = null; // Cache the folder tree

        // Track expanded folders in hierarchy view with sessionStorage persistence
        let expandedFolders = new Set();

        // Load expanded folders from sessionStorage
        function loadExpandedState() {
            try {
                const saved = sessionStorage.getItem('knowledgetree_expanded_folders');
                if (saved) {
                    expandedFolders = new Set(JSON.parse(saved));
                }
            } catch (error) {
                console.error('Failed to load expanded state:', error);
            }
        }

        // Save expanded folders to sessionStorage
        function saveExpandedState() {
            try {
                sessionStorage.setItem('knowledgetree_expanded_folders', JSON.stringify([...expandedFolders]));
            } catch (error) {
                console.error('Failed to save expanded state:', error);
            }
        }

        // Initialize expanded state from sessionStorage
        loadExpandedState();

        function createFolderTreeNode(folder, level = 0) {
            const li = document.createElement('li');
            li.className = 'folder-tree__item';

            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'folder-tree__node';
            nodeDiv.dataset.folderId = folder.id;

            // Toggle button (for expand/collapse)
            const toggle = document.createElement('span');
            toggle.className = 'folder-tree__toggle';
            if (folder.children && folder.children.length > 0) {
                toggle.innerHTML = '<i data-lucide="chevron-right" style="width: 16px; height: 16px;"></i>';
            } else {
                toggle.innerHTML = '';
            }

            // Folder icon
            const icon = document.createElement('span');
            icon.className = 'folder-tree__icon';
            icon.textContent = folder.is_attached ? 'üìé' : 'üìÅ';

            // Folder name
            const name = document.createElement('span');
            name.className = 'folder-tree__name';
            name.textContent = folder.name;

            nodeDiv.appendChild(toggle);
            nodeDiv.appendChild(icon);
            nodeDiv.appendChild(name);

            // Click handler for selection
            nodeDiv.addEventListener('click', (e) => {
                e.stopPropagation();

                // Handle toggle click
                if (e.target.closest('.folder-tree__toggle') === toggle && folder.children && folder.children.length > 0) {
                    const childrenUl = li.querySelector('.folder-tree__children');
                    if (childrenUl) {
                        const isCollapsed = childrenUl.classList.contains('folder-tree__children--collapsed');
                        childrenUl.classList.toggle('folder-tree__children--collapsed');
                        toggle.innerHTML = isCollapsed ? '<i data-lucide="chevron-down" style="width: 16px; height: 16px;"></i>' : '<i data-lucide="chevron-right" style="width: 16px; height: 16px;"></i>';
                        lucide.createIcons(); // Re-initialize the new icon
                    }
                    return;
                }

                // Handle folder selection
                document.querySelectorAll('.folder-tree__node').forEach(n => {
                    n.classList.remove('folder-tree__node--selected');
                });
                nodeDiv.classList.add('folder-tree__node--selected');
                selectedDestinationId = folder.id;
            });

            li.appendChild(nodeDiv);

            // Add children
            if (folder.children && folder.children.length > 0) {
                const childrenUl = document.createElement('ul');
                childrenUl.className = 'folder-tree__children folder-tree__children--collapsed';

                folder.children.forEach(child => {
                    childrenUl.appendChild(createFolderTreeNode(child, level + 1));
                });

                li.appendChild(childrenUl);
            }

            return li;
        }

        document.getElementById('context-move').addEventListener('click', async () => {
            if (!selectedItemId) return;

            const moveModal = document.getElementById('move-modal');
            const folderList = document.getElementById('folder-list');

            selectedDestinationId = null;
            moveModal.classList.add('active');

            // If we have cached tree, show it immediately
            if (cachedFolderTree) {
                folderList.innerHTML = '';
                const ul = document.createElement('ul');
                ul.className = 'folder-tree';
                ul.appendChild(createFolderTreeNode(cachedFolderTree));
                folderList.appendChild(ul);
                lucide.createIcons();
                return;
            }

            // Show loading state for first load
            folderList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--color-text-secondary);">Loading folders...</div>';

            // Fetch folder tree in background
            try {
                const response = await fetch('{{ url_for("get_folder_tree") }}', {
                    credentials: 'same-origin'
                });
                const folderTree = await response.json();
                cachedFolderTree = folderTree; // Cache for next time

                // Build folder tree UI
                folderList.innerHTML = '';
                const ul = document.createElement('ul');
                ul.className = 'folder-tree';
                ul.appendChild(createFolderTreeNode(folderTree));
                folderList.appendChild(ul);

                // Initialize Lucide icons in the folder tree
                lucide.createIcons();
            } catch (error) {
                folderList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--color-danger);">Error loading folders. Please try again.</div>';
                console.error('Failed to load folder tree:', error);
            }
        });

        document.getElementById('confirm-move-btn').addEventListener('click', async () => {
            if (!selectedDestinationId || !selectedItemId) {
                alert('Please select a destination folder');
                return;
            }

            // Get the item's data before removing it
            const movedItem = document.querySelector(`.file-item[data-id="${selectedItemId}"], .hierarchy-item[data-id="${selectedItemId}"]`);
            const itemData = movedItem ? {
                id: movedItem.dataset.id,
                name: movedItem.dataset.name,
                is_folder: movedItem.dataset.isFolder === 'true',
                is_attached: movedItem.querySelector('.file-item__icon, .hierarchy-item__icon')?.textContent === 'üìé'
            } : null;

            const basePath = window.location.pathname.startsWith('/knowledgetree/') ? '/knowledgetree' : '';
            const response = await fetch(`${basePath}/api/node/${selectedItemId}/move`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify({ new_parent_id: selectedDestinationId })
            });

            if (response.ok) {
                // Close modal
                document.getElementById('move-modal').classList.remove('active');

                // Invalidate cached folder tree
                cachedFolderTree = null;

                // Remove the moved item from DOM
                if (movedItem) {
                    // In hierarchy view, also remove the children container if it exists
                    if (movedItem.classList.contains('hierarchy-item')) {
                        const childrenDiv = movedItem.nextElementSibling;
                        if (childrenDiv && childrenDiv.classList.contains('hierarchy-children')) {
                            childrenDiv.remove();
                        }
                    }
                    movedItem.remove();
                }

                // Try to add the item to destination if it's visible and expanded
                if (itemData && currentView === 'hierarchy') {
                    const destChildrenDiv = document.querySelector(`.hierarchy-children[data-parent-id="${selectedDestinationId}"]`);
                    if (destChildrenDiv && destChildrenDiv.classList.contains('hierarchy-children--expanded')) {
                        // Add the item to the expanded destination folder
                        await createHierarchyItem(itemData, destChildrenDiv, 0);
                        lucide.createIcons();
                    }
                }

                // In grid/tree view, check if destination is the current folder
                if (itemData && (currentView === 'grid' || currentView === 'tree') && selectedDestinationId === CURRENT_NODE_ID) {
                    // Item was moved INTO the current folder, add it to the view
                    const newItem = document.createElement('div');
                    newItem.className = 'file-item';
                    if (itemData.is_folder && itemData.is_attached) {
                        newItem.innerHTML = `
                            <span class="file-item__icon">üìé</span>
                            <span class="file-item__name">${itemData.name}</span>
                        `;
                    } else if (itemData.is_folder) {
                        newItem.innerHTML = `
                            <span class="file-item__icon">üìÅ</span>
                            <span class="file-item__name">${itemData.name}</span>
                        `;
                    } else {
                        newItem.innerHTML = `
                            <span class="file-item__icon">üìÑ</span>
                            <span class="file-item__name">${itemData.name}</span>
                        `;
                    }
                    newItem.dataset.id = itemData.id;
                    newItem.dataset.name = itemData.name;
                    newItem.dataset.isFolder = itemData.is_folder;

                    // Add click handler
                    newItem.addEventListener('click', () => {
                        if (itemData.is_folder) {
                            const newPath = CURRENT_PATH ? `${CURRENT_PATH}/${encodeURIComponent(itemData.name)}` : encodeURIComponent(itemData.name);
                            window.location.href = `{{ url_for('browse', path='') }}${newPath}`;
                        } else {
                            window.location.href = `{{ url_for('view_node', node_id='') }}${itemData.id}`;
                        }
                    });

                    fileBrowserElement.appendChild(newItem);
                }

                // Clear selection
                selectedItemId = null;
            } else {
                const error = await response.json();
                alert(`Error: ${error.error || 'Failed to move item'}`);
            }
        });

        document.getElementById('close-move-modal').addEventListener('click', () => {
            document.getElementById('move-modal').classList.remove('active');
        });

        document.getElementById('cancel-move-btn').addEventListener('click', () => {
            document.getElementById('move-modal').classList.remove('active');
        });

        // Close modal on background click
        window.addEventListener('click', (event) => {
            const moveModal = document.getElementById('move-modal');
            if (event.target == moveModal) {
                moveModal.classList.remove('active');
            }
        });

        // Search functionality
        const searchInput = document.getElementById('search-input');
        const searchScope = document.getElementById('search-scope');
        const searchResults = document.getElementById('search-results');
        let searchDebounceTimer;

        async function performSearch() {
            clearTimeout(searchDebounceTimer);
            searchDebounceTimer = setTimeout(async () => {
                const query = searchInput.value.trim();
                if (query.length < 2) {
                    searchResults.classList.remove('dropdown--visible');
                    return;
                }

                // Determine start node based on scope selection
                const scope = searchScope.value;
                const startNodeId = scope === 'all' ? 'root' : CURRENT_NODE_ID;

                const response = await fetch(`{{ url_for('search_nodes') }}?query=${encodeURIComponent(query)}&start_node_id=${startNodeId}`, {
                    credentials: 'same-origin'
                });
                const items = await response.json();

                searchResults.innerHTML = '';
                if (items.length === 0) {
                    searchResults.innerHTML = '<div class="dropdown__empty">No results found.</div>';
                } else {
                    items.forEach(item => {
                        const div = document.createElement('div');
                        div.className = 'dropdown__item';
                        div.innerHTML = `<div class="dropdown__item-title">${item.name}</div><div class="dropdown__item-subtitle">${item.folder_path}</div>`;
                        div.addEventListener('click', () => {
                            if (item.is_folder) {
                                window.location.href = `{{ url_for('browse', path='') }}${item.url_path}`;
                            } else {
                                window.location.href = `{{ url_for('view_node', node_id='') }}${item.id}`;
                            }
                        });
                        searchResults.appendChild(div);
                    });
                }

                const rect = searchInput.getBoundingClientRect();
                searchResults.style.top = `${rect.bottom + window.scrollY}px`;
                searchResults.style.left = `${rect.left + window.scrollX}px`;
                searchResults.style.width = `${rect.width}px`;
                searchResults.classList.add('dropdown--visible');
            }, 300);
        }

        searchInput.addEventListener('input', performSearch);
        searchScope.addEventListener('change', performSearch);

        document.addEventListener('click', (e) => {
            if (!searchResults.contains(e.target) && e.target !== searchInput && e.target !== searchScope) {
                searchResults.classList.remove('dropdown--visible');
            }
        });

        // View switcher functionality
        const fileBrowserElement = document.getElementById('file-browser');
        const viewGridBtn = document.getElementById('view-grid');
        const viewTreeBtn = document.getElementById('view-tree');
        const viewHierarchyBtn = document.getElementById('view-hierarchy');
        let currentView = 'grid'; // Default
        let originalHTML = fileBrowserElement.innerHTML; // Save original HTML for switching back
        const basePath = window.location.pathname.startsWith('/knowledgetree/') ? '/knowledgetree' : '';

        // Load user's view preference from Codex
        async function loadViewPreference() {
            try {
                const response = await fetch('/codex/api/my/settings', {
                    credentials: 'same-origin'
                });
                if (response.ok) {
                    const data = await response.json();
                    const savedView = data.knowledgetree_view_preference || 'grid';
                    await setView(savedView, false); // Don't save on initial load
                }
            } catch (error) {
                console.error('Failed to load view preference:', error);
                // Show content even if preference load fails
                fileBrowserElement.style.opacity = '1';
            }
        }

        // Save view preference to Codex
        async function saveViewPreference(view) {
            try {
                await fetch('/codex/api/my/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({ knowledgetree_view_preference: view })
                });
            } catch (error) {
                console.error('Failed to save view preference:', error);
            }
        }

        // Build hierarchy view
        async function buildHierarchyView() {
            // Get all items from the current view BEFORE clearing
            const fileItems = document.querySelectorAll('.file-item');

            // Now clear the content
            fileBrowserElement.innerHTML = '';

            // Convert existing file items to hierarchy items
            for (const fileItem of fileItems) {
                const item = {
                    id: fileItem.dataset.id,
                    name: fileItem.dataset.name,
                    is_folder: fileItem.dataset.isFolder === 'true',
                    is_attached: fileItem.querySelector('.file-item__icon').textContent === 'üìé',
                    read_only: fileItem.classList.contains('file-item--read-only')
                };
                await createHierarchyItem(item, fileBrowserElement);
            }
        }

        async function createHierarchyItem(item, container, level = 0) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'hierarchy-item';
            itemDiv.dataset.id = item.id;
            itemDiv.dataset.name = item.name;
            itemDiv.dataset.isFolder = item.is_folder;

            // Toggle for folders
            const toggle = document.createElement('span');
            toggle.className = 'hierarchy-item__toggle';
            if (item.is_folder) {
                toggle.innerHTML = '<i data-lucide="chevron-right" style="width: 16px; height: 16px;"></i>';
            } else {
                toggle.innerHTML = '';
            }

            // Icon
            const icon = document.createElement('span');
            icon.className = 'hierarchy-item__icon';
            if (item.is_folder) {
                icon.textContent = item.is_attached ? 'üìé' : 'üìÅ';
            } else {
                icon.textContent = 'üìÑ';
            }

            // Name
            const name = document.createElement('span');
            name.className = 'hierarchy-item__name';
            name.textContent = item.name;

            itemDiv.appendChild(toggle);
            itemDiv.appendChild(icon);
            itemDiv.appendChild(name);

            // Children container
            const childrenDiv = document.createElement('div');
            childrenDiv.className = 'hierarchy-children';
            childrenDiv.dataset.parentId = item.id;

            // Click handler for toggle arrow
            toggle.addEventListener('click', async (e) => {
                e.stopPropagation();
                e.preventDefault();

                console.log('Toggle clicked for:', item.name, 'is_folder:', item.is_folder);

                if (!item.is_folder) return;

                // Toggle children
                const isExpanded = childrenDiv.classList.contains('hierarchy-children--expanded');

                if (isExpanded) {
                    childrenDiv.classList.remove('hierarchy-children--expanded');
                    toggle.innerHTML = '<i data-lucide="chevron-right" style="width: 16px; height: 16px;"></i>';
                    lucide.createIcons();
                    expandedFolders.delete(item.id); // Track collapsed state
                    saveExpandedState();
                } else {
                    // Load children if not loaded yet
                    if (childrenDiv.children.length === 0) {
                        console.log('Loading children for:', item.id);
                        const url = `${basePath}/api/node/${item.id}/children`;
                        console.log('Fetching from:', url);
                        const response = await fetch(url, {
                            credentials: 'same-origin'
                        });
                        console.log('Response status:', response.status);
                        if (response.ok) {
                            const children = await response.json();
                            console.log('Got children:', children);
                            for (const child of children) {
                                await createHierarchyItem(child, childrenDiv, level + 1);
                            }
                        } else {
                            console.error('Failed to load children:', response.status);
                        }
                    }
                    childrenDiv.classList.add('hierarchy-children--expanded');
                    toggle.innerHTML = '<i data-lucide="chevron-down" style="width: 16px; height: 16px;"></i>';
                    lucide.createIcons();
                    expandedFolders.add(item.id); // Track expanded state
                    saveExpandedState();
                }
            });

            // Click handler for the item itself
            itemDiv.addEventListener('click', async (e) => {
                e.stopPropagation();

                if (item.is_folder) {
                    // For folders: expand/collapse instead of navigating
                    const isExpanded = childrenDiv.classList.contains('hierarchy-children--expanded');

                    if (isExpanded) {
                        childrenDiv.classList.remove('hierarchy-children--expanded');
                        toggle.innerHTML = '<i data-lucide="chevron-right" style="width: 16px; height: 16px;"></i>';
                        lucide.createIcons();
                        expandedFolders.delete(item.id); // Track collapsed state
                        saveExpandedState();
                    } else {
                        // Load children if not loaded yet
                        if (childrenDiv.children.length === 0) {
                            console.log('Loading children for:', item.id);
                            const url = `${basePath}/api/node/${item.id}/children`;
                            console.log('Fetching from:', url);
                            const response = await fetch(url, {
                                credentials: 'same-origin'
                            });
                            console.log('Response status:', response.status);
                            if (response.ok) {
                                const children = await response.json();
                                console.log('Got children:', children);
                                for (const child of children) {
                                    await createHierarchyItem(child, childrenDiv, level + 1);
                                }
                            } else {
                                console.error('Failed to load children:', response.status);
                            }
                        }
                        childrenDiv.classList.add('hierarchy-children--expanded');
                        toggle.innerHTML = '<i data-lucide="chevron-down" style="width: 16px; height: 16px;"></i>';
                        lucide.createIcons();
                        expandedFolders.add(item.id); // Track expanded state
                        saveExpandedState();
                    }
                } else {
                    // For files: navigate to view
                    window.location.href = `{{ url_for('view_node', node_id='') }}${item.id}`;
                }
            });

            container.appendChild(itemDiv);
            if (item.is_folder) {
                container.appendChild(childrenDiv);

                // Restore expanded state if this folder was previously expanded
                if (expandedFolders.has(item.id)) {
                    // Load children and expand
                    const url = `${basePath}/api/node/${item.id}/children`;
                    fetch(url, { credentials: 'same-origin' })
                        .then(response => response.json())
                        .then(children => {
                            children.forEach(child => {
                                createHierarchyItem(child, childrenDiv, level + 1);
                            });
                            childrenDiv.classList.add('hierarchy-children--expanded');
                            toggle.innerHTML = '<i data-lucide="chevron-down" style="width: 16px; height: 16px;"></i>';
                            lucide.createIcons();
                        })
                        .catch(error => console.error('Failed to restore expanded state:', error));
                }
            }
        }

        // Set the view (grid, tree, or hierarchy)
        async function setView(view, save = true) {
            const previousView = currentView; // Save previous view before updating
            currentView = view;

            // Remove all view classes
            fileBrowserElement.classList.remove('file-browser--tree', 'file-browser--hierarchy');

            // Remove active from all buttons
            viewGridBtn.classList.remove('view-switcher__button--active');
            viewTreeBtn.classList.remove('view-switcher__button--active');
            viewHierarchyBtn.classList.remove('view-switcher__button--active');

            if (view === 'grid') {
                // Restore original HTML if coming from hierarchy
                if (previousView === 'hierarchy') {
                    fileBrowserElement.innerHTML = originalHTML;
                    attachFileItemHandlers(); // Re-attach click handlers
                }
                viewGridBtn.classList.add('view-switcher__button--active');
            } else if (view === 'tree') {
                // Restore original HTML if coming from hierarchy
                if (previousView === 'hierarchy') {
                    fileBrowserElement.innerHTML = originalHTML;
                    attachFileItemHandlers(); // Re-attach click handlers
                }
                fileBrowserElement.classList.add('file-browser--tree');
                viewTreeBtn.classList.add('view-switcher__button--active');
            } else if (view === 'hierarchy') {
                fileBrowserElement.classList.add('file-browser--hierarchy');
                viewHierarchyBtn.classList.add('view-switcher__button--active');
                await buildHierarchyView();
                lucide.createIcons(); // Initialize icons in hierarchy view
            }

            // Make visible after view is set
            fileBrowserElement.style.opacity = '1';

            if (save) {
                saveViewPreference(view);
            }
        }

        // View switcher button handlers
        viewGridBtn.addEventListener('click', () => setView('grid'));
        viewTreeBtn.addEventListener('click', () => setView('tree'));
        viewHierarchyBtn.addEventListener('click', () => setView('hierarchy'));

        // Load preference on page load
        loadViewPreference();

        // Initialize Lucide icons
        lucide.createIcons();
    </script>
</body>
</html>
